{
    "cells": [
        {
            "language": "typescript",
            "source": [
                "// Setup: Configuration and Types\n// Based on Fiddler REST API v3.0 specification\n\n// Environment configuration\nconst API_KEY = process.env.FIDDLER_API_KEY || \"\";\nconst FIDDLER_ENDPOINT = process.env.FIDDLER_ENDPOINT || \"\";\nconst MODEL_ID = process.env.MODEL_ID || \"\";\n\n// Type Definitions matching Fiddler API v3.0\ninterface FiddlerEvent {\n    customer_id: string;\n    creditscore: number;\n    geography: string;\n    gender: string;\n    age: number;\n    tenure: number;\n    balance: number;\n    numofproducts: number;\n    hascrcard: number;\n    isactivemember: number;\n    estimatedsalary: number;\n    predicted_churn: number;\n    churn: string;\n    timestamp: string;\n}\n\ninterface PublishPayload {\n    model_id: string;\n    env_type: \"PRODUCTION\" | \"PRE_PRODUCTION\";\n    env_name?: string;\n    source: FileSource | EventsSource;\n}\n\ninterface FileSource {\n    type: \"FILE\";\n    file_id: string;\n}\n\ninterface EventsSource {\n    type: \"EVENTS\";\n    events: FiddlerEvent[];\n}\n\n// API v3.0 Response Envelope\ninterface ApiResponse<T> {\n    api_version: string;\n    kind: string;\n    data: T;\n}\n\n// File Upload Response\ninterface FileUploadData {\n    id: string;\n    filename: string;\n    type: string;\n    status: string;\n    created_at: string;\n    updated_at?: string;\n}\n\n// Batch Publish Response\ninterface BatchPublishData {\n    job: {\n        id: string;\n        name: string;\n    };\n}\n\n// Streaming Publish Response\ninterface StreamingPublishData {\n    source_type: string;\n    event_ids: string[];\n}\n\nconsole.log(\"\u2713 Configuration and types loaded\");\nconsole.log(`  Endpoint: ${FIDDLER_ENDPOINT}`);\nconsole.log(`  Model ID: ${MODEL_ID}`);"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Test 1: File Upload for Batch Publishing\n// Upload CSV file and get file_id for batch publish\n\nimport * as fs from 'fs';\nimport { Blob } from 'buffer';\n\n// Create test CSV with bank churn data\nconst csvContent = `customer_id,creditscore,geography,gender,age,tenure,balance,numofproducts,hascrcard,isactivemember,estimatedsalary,predicted_churn,churn,timestamp\n27c349a2,559,California,Male,52,2,0.0,1,1,0,129013.59,0.007447,no,2025-12-24T12:00:00Z\n27c35cee,482,California,Male,55,5,97318.25,1,0,1,78416.14,0.804852,yes,2025-12-25T12:01:00Z\n27c364f0,651,Florida,Female,46,4,89743.05,1,1,0,156425.57,0.012754,no,2025-12-23T12:02:00Z`;\n\nfs.writeFileSync('churn_events.csv', csvContent);\nconsole.log(\"\u2713 Created test CSV file\");\n\n// Upload file using native FormData (Node 18+)\nconst fileBuffer = fs.readFileSync('churn_events.csv');\nconst blob = new Blob([fileBuffer], { type: 'text/csv' });\nconst formData = new FormData();\nformData.append('file', blob, 'churn_events.csv');\n\nconst uploadResponse = await fetch(`${FIDDLER_ENDPOINT}/v3/files/upload`, {\n    method: 'POST',\n    headers: {\n        'Authorization': `Bearer ${API_KEY}`\n    },\n    body: formData\n});\n\nif (!uploadResponse.ok) {\n    const errorText = await uploadResponse.text();\n    throw new Error(`File upload failed (${uploadResponse.status}): ${errorText}`);\n}\n\nconst uploadResult: ApiResponse<FileUploadData> = await uploadResponse.json();\nconst fileId = uploadResult.data.id;\n\nconsole.log(`\u2713 File uploaded successfully`);\nconsole.log(`  File ID: ${fileId}`);\nconsole.log(`  Filename: ${uploadResult.data.filename}`);\nconsole.log(`  Status: ${uploadResult.data.status}`);"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Test 2: Batch Publish Using Uploaded File\n// Publish events from the uploaded file (returns job_id)\n\nconst batchPayload: PublishPayload = {\n    model_id: MODEL_ID,\n    env_type: \"PRODUCTION\",\n    source: {\n        type: \"FILE\",\n        file_id: fileId  // From previous cell\n    }\n};\n\nconst batchResponse = await fetch(`${FIDDLER_ENDPOINT}/v3/events`, {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n    },\n    body: JSON.stringify(batchPayload)\n});\n\nif (!batchResponse.ok) {\n    const errorText = await batchResponse.text();\n    throw new Error(`Batch publish failed (${batchResponse.status}): ${errorText}`);\n}\n\n// Batch publish returns 202 Accepted with job ID\nif (batchResponse.status !== 202) {\n    console.warn(`\u26a0\ufe0f  Expected status 202, got ${batchResponse.status}`);\n}\n\nconst batchResult: ApiResponse<BatchPublishData> = await batchResponse.json();\nconst jobId = batchResult.data.job.id;\n\nconsole.log(`\u2713 Batch publish started`);\nconsole.log(`  Job ID: ${jobId}`);\nconsole.log(`  Job Name: ${batchResult.data.job.name}`);"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Test 3: Streaming Publish (Direct Events)\n// Publish events directly without file upload\n\nconst events: FiddlerEvent[] = [\n    {\n        customer_id: \"27c349a2\",\n        creditscore: 559,\n        geography: \"California\",\n        gender: \"Male\",\n        age: 52,\n        tenure: 2,\n        balance: 0.0,\n        numofproducts: 1,\n        hascrcard: 1,\n        isactivemember: 0,\n        estimatedsalary: 129013.59,\n        predicted_churn: 0.007447,\n        churn: \"no\",\n        timestamp: new Date().toISOString()\n    },\n    {\n        customer_id: \"27c35cee\",\n        creditscore: 482,\n        geography: \"California\",\n        gender: \"Male\",\n        age: 55,\n        tenure: 5,\n        balance: 97318.25,\n        numofproducts: 1,\n        hascrcard: 0,\n        isactivemember: 1,\n        estimatedsalary: 78416.14,\n        predicted_churn: 0.804852,\n        churn: \"yes\",\n        timestamp: new Date().toISOString()\n    }\n];\n\nconst streamingPayload: PublishPayload = {\n    model_id: MODEL_ID,\n    env_type: \"PRODUCTION\",\n    source: {\n        type: \"EVENTS\",\n        events: events\n    }\n};\n\nconst streamingResponse = await fetch(`${FIDDLER_ENDPOINT}/v3/events`, {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n    },\n    body: JSON.stringify(streamingPayload)\n});\n\nif (!streamingResponse.ok) {\n    const errorText = await streamingResponse.text();\n    throw new Error(`Streaming publish failed (${streamingResponse.status}): ${errorText}`);\n}\n\n// Streaming publish returns 202 Accepted (like batch publish)\nif (streamingResponse.status !== 202) {\n    console.warn(`\u26a0\ufe0f  Expected status 202, got ${streamingResponse.status}`);\n}\n\nconst streamingResult: ApiResponse<StreamingPublishData> = await streamingResponse.json();\nconst eventIds = streamingResult.data.event_ids;\n\nconsole.log(`\u2713 Streaming publish completed`);\nconsole.log(`  Published ${eventIds.length} event(s)`);\nconsole.log(`  Event IDs: ${eventIds.join(', ')}`);"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Test 4: Update Existing Events\n// Update events using PATCH\n//\n// IMPORTANT: Only PRODUCTION events can be updated.\n// Non-production events (PRE_PRODUCTION) are immutable and cannot be\n// modified via batch OR streaming processes.\n\nconst updates: Partial<FiddlerEvent>[] = [\n    {\n        customer_id: \"27c349a2\",\n        churn: \"yes\"  // Update prediction\n    }\n];\n\nconst updatePayload = {\n    model_id: MODEL_ID,\n    env_type: \"PRODUCTION\",\n    source: {\n        type: \"EVENTS\",\n        events: updates\n    }\n};\n\nconst updateResponse = await fetch(`${FIDDLER_ENDPOINT}/v3/events`, {\n    method: 'PATCH',\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${API_KEY}`\n    },\n    body: JSON.stringify(updatePayload)\n});\n\nif (!updateResponse.ok) {\n    const errorText = await updateResponse.text();\n    throw new Error(`Update failed (${updateResponse.status}): ${errorText}`);\n}\n\nconsole.log(`\u2713 Update completed`);\nconsole.log(`  Status: ${updateResponse.status}`);\n\n// Clean up test file\nfs.unlinkSync('churn_events.csv');\nconsole.log(`\\n\u2713 Cleanup completed - removed test CSV file`);"
            ],
            "outputs": []
        },
        {
            "language": "typescript",
            "source": [
                "// Production-Ready Publisher Class\n// Complete implementation with retry logic and error handling\n\nclass FiddlerPublisher {\n    private apiKey: string;\n    private endpoint: string;\n    private maxRetries: number;\n    private initialDelay: number;\n    private backoffMultiplier: number;\n\n    constructor(\n        apiKey: string,\n        endpoint: string,\n        options: {\n            maxRetries?: number;\n            initialDelay?: number;\n            backoffMultiplier?: number;\n        } = {}\n    ) {\n        this.apiKey = apiKey;\n        this.endpoint = endpoint;\n        this.maxRetries = options.maxRetries ?? 3;\n        this.initialDelay = options.initialDelay ?? 1000;\n        this.backoffMultiplier = options.backoffMultiplier ?? 2;\n    }\n\n    private async delay(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n\n    private calculateBackoff(attempt: number): number {\n        return this.initialDelay * Math.pow(this.backoffMultiplier, attempt);\n    }\n\n    private isRetryable(status: number): boolean {\n        return [429, 500, 502, 503, 504].includes(status);\n    }\n\n    async publishEventsWithRetry(\n        modelId: string,\n        events: FiddlerEvent[],\n        envType: \"PRODUCTION\" | \"PRE_PRODUCTION\" = \"PRODUCTION\"\n    ): Promise<string[]> {\n        if (events.length === 0) {\n            throw new Error(\"Events array cannot be empty\");\n        }\n\n        const payload: PublishPayload = {\n            model_id: modelId,\n            env_type: envType,\n            source: {\n                type: \"EVENTS\",\n                events: events\n            }\n        };\n\n        let lastError: Error | null = null;\n\n        for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n            try {\n                // Add delay for retries\n                if (attempt > 0) {\n                    const delayMs = this.calculateBackoff(attempt - 1);\n                    console.log(`Retry attempt ${attempt}/${this.maxRetries} after ${delayMs}ms`);\n                    await this.delay(delayMs);\n                }\n\n                const headers: Record<string, string> = {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.apiKey}`\n                };\n\n                if (attempt > 0) {\n                    headers['X-Fiddler-Client-Retry'] = 'true';\n                }\n\n                const response = await fetch(`${this.endpoint}/v3/events`, {\n                    method: 'POST',\n                    headers: headers,\n                    body: JSON.stringify(payload)\n                });\n\n                // Streaming returns 202 Accepted (both batch and streaming use 202)\n                if (response.status === 200 || response.status === 202) {\n                    const result: ApiResponse<StreamingPublishData> = await response.json();\n                    if (attempt > 0) {\n                        console.log(`\u2713 Succeeded on retry attempt ${attempt}`);\n                    }\n                    return result.data.event_ids;\n                }\n\n                // Check if error is retryable\n                if (!this.isRetryable(response.status)) {\n                    const errorText = await response.text();\n                    throw new Error(\n                        `Non-retryable error (${response.status}): ${errorText}`\n                    );\n                }\n\n                const errorText = await response.text();\n                lastError = new Error(`HTTP ${response.status}: ${errorText}`);\n\n            } catch (error) {\n                if (error instanceof Error && !error.message.includes('Non-retryable')) {\n                    lastError = error;\n                    if (attempt === this.maxRetries) {\n                        break;\n                    }\n                } else {\n                    throw error;\n                }\n            }\n        }\n\n        throw new Error(\n            `Max retries (${this.maxRetries}) exceeded. Last error: ${lastError?.message}`\n        );\n    }\n}\n\nconsole.log(\"\u2713 FiddlerPublisher class defined\");\n\n// Test the production publisher\nconst publisher = new FiddlerPublisher(API_KEY, FIDDLER_ENDPOINT, {\n    maxRetries: 2,\n    initialDelay: 1000\n});\n\nconst testEvents: FiddlerEvent[] = [\n    {\n        customer_id: \"test1_\" + Date.now(),\n        creditscore: 650,\n        geography: \"New York\",\n        gender: \"Female\",\n        age: 31,\n        tenure: 8,\n        balance: 50000.1,\n        numofproducts: 1,\n        hascrcard: 1,\n        isactivemember: 1,\n        estimatedsalary: 95000.00,\n        predicted_churn: 0.15,\n        churn: \"no\",\n        timestamp: new Date().toISOString()\n    }\n];\n\nconst publishedIds = await publisher.publishEventsWithRetry(MODEL_ID, testEvents);\nconsole.log(`\\n\u2713 Production publisher test completed`);\nconsole.log(`  Published ${publishedIds.length} event(s)`);\nconsole.log(`  Event IDs: ${publishedIds.join(', ')}`);"
            ],
            "outputs": []
        }
    ]
}